schema {
  query: Query
  mutation: Mutation
}

enum GroupType {
  NODE
  PROCESS
}

input DurationInput {
  hours: Int!
  minutes: Int!
  seconds: Int!
}

input InputDataSetupUpdate {
  containsReserves: Boolean
  containsOnline: Boolean
  containsStates: Boolean
  containsPiecewiseEff: Boolean
  containsRisk: Boolean
  containsDiffusion: Boolean
  containsDelay: Boolean
  containsMarkets: Boolean
  reserveRealization: Boolean
  useMarketBids: Boolean
  commonTimesteps: Int
  commonScenarioName: String
  useNodeDummyVariables: Boolean
  useRampDummyVariables: Boolean
  nodeDummyVariableCost: Float
  rampDummyVariableCost: Float
}

"Location input."
input LocationInput {
  "Country." country: String
  "Place within the country." place: String
}

input NewGenConstraint {
  name: String!
  gcType: String!
  isSetpoint: Boolean!
  penalty: Float!
  constant: Float
}

input NewMarket {
  name: String!
  mType: String!
  node: String!
  processgroup: String!
  direction: String
  realisation: Float
  reserveType: String
  isBid: Boolean!
  isLimited: Boolean!
  minBid: Float!
  maxBid: Float!
  fee: Float!
  price: Float
  upPrice: Float
  downPrice: Float
  reserveActivationPrice: Float
}

input NewNode {
  name: String!
  isCommodity: Boolean!
  isMarket: Boolean!
  isRes: Boolean!
  cost: Float
  inflow: Float
}

input NewProcess {
  name: String!
  "Must be 'unit' or 'transport'." conversion: String!
  isCfFix: Boolean!
  isOnline: Boolean!
  isRes: Boolean!
  eff: Float!
  loadMin: Float!
  loadMax: Float!
  startCost: Float!
  minOnline: Float!
  maxOnline: Float!
  minOffline: Float!
  maxOffline: Float!
  initialState: Boolean!
  isScenarioIndependent: Boolean!
  cf: Float
  effTs: Float
}

input NewRisk {
  parameter: String!
  value: Float!
}

input NewTopology {
  capacity: Float!
  vomCost: Float!
  rampUp: Float!
  rampDown: Float!
  initialLoad: Float!
  initialFlow: Float!
  capTs: Float
}

input SettingsInput {
  location: LocationInput
}

input StateInput {
  inMax: Float!
  outMax: Float!
  stateLossProportional: Float!
  stateMin: Float!
  stateMax: Float!
  initialState: Float!
  isScenarioIndependent: Boolean!
  isTemp: Boolean!
  tEConversion: Float!
  residualValue: Float!
}

input StateUpdate {
  inMax: Float
  outMax: Float
  stateLossProportional: Float
  stateMax: Float
  stateMin: Float
  initialState: Float
  isScenarioIndependent: Boolean
  isTemp: Boolean
  tEConversion: Float
  residualValue: Float
}

input TimeLineUpdate {
  duration: DurationInput
  step: DurationInput
}

type ConFactor {
  varType: String!
  varTuple: VariableId!
  data: Float!
}

"Delay for connections between nodes."
type Delay {
  fromNode: String!
  toNode: String!
  delay: Float!
  minDelayFlow: Float!
  maxDelayFlow: Float!
}

type Duration {
  hours: Int!
  minutes: Int!
  seconds: Int!
}

type GenConstraint {
  name: String!
  gcType: String!
  isSetpoint: Boolean!
  penalty: Float!
  factors: [ConFactor!]!
  constant: Float
}

type Group {
  name: String!
  gType: GroupType!
  members: [String!]!
}

type InflowBlock {
  name: String!
  node: String!
  data: Float!
}

"The model itself."
type InputData {
  scenarios: [Scenario!]!
  setup: InputDataSetup!
  processes: [Process!]!
  nodes: [Node!]!
  nodeDiffusion: [NodeDiffusion!]!
  nodeDelay: [Delay!]!
  nodeHistories: [NodeHistory!]!
  markets: [Market!]!
  groups: [Group!]!
  reserveType: [ReserveType!]!
  risk: [Risk!]!
  inflowBlocks: [InflowBlock!]!
  genConstraints: [GenConstraint!]!
}

type InputDataSetup {
  containsReserves: Boolean!
  containsOnline: Boolean!
  containsStates: Boolean!
  containsPiecewiseEff: Boolean!
  containsRisk: Boolean!
  containsDiffusion: Boolean!
  containsDelay: Boolean!
  containsMarkets: Boolean!
  reserveRealisation: Boolean!
  useMarketBids: Boolean!
  commonTimesteps: Int!
  commonScenarioName: String!
  useNodeDummyVariables: Boolean!
  useRampDummyVariables: Boolean!
  nodeDummyVariableCost: Float!
  rampDummyVariableCost: Float!
}

type LocationSettings {
  "Country."
  country: String!
  "Place within country."
  place: String!
}

type Market {
  name: String!
  mType: String!
  node: String!
  processgroup: String!
  direction: String!
  realisation: Float
  reserveType: String!
  isBid: Boolean!
  isLimited: Boolean!
  minBid: Float!
  maxBid: Float!
  fee: Float!
  price: Float
  upPrice: Float
  downPrice: Float
  reserveActivationPrice: Float
  fixed: [MarketFix!]!
}

type MarketFix {
  name: String!
  factor: Float!
}

type MaybeError {
  "Error message; if null, the operation succeeded."
  error: String
}

"Optimization model."
type Model {
  timeLine: TimeLineSettings!
  inputData: InputData!
}

type Mutation {
  startOptimization: StartOptimizationResult!
  "Update model's time line."
  updateTimeLine(timeLineInput: TimeLineUpdate!): ValidationErrors!
  "Create new scenario."
  createScenario(name: String!, weight: Float!): MaybeError!
  "Save the model on disk."
  saveModel: MaybeError!
  "Clear input data from model."
  clearInputData: MaybeError!
  "Update input data setup."
  updateInputDataSetup(setupUpdate: InputDataSetupUpdate!): ValidationErrors!
  "Create new node group"
  createNodeGroup(name: String!): MaybeError!
  "Create new process group."
  createProcessGroup(name: String!): MaybeError!
  "Create new process."
  createProcess(process: NewProcess!): ValidationErrors!
  "Add process to process group."
  addProcessToGroup(processName: String!, groupName: String!): MaybeError!
  "Create new topology and add it to process."
  createTopology(topology: NewTopology!, sourceNodeName: String, processName: String!, sinkNodeName: String): ValidationErrors!
  "Create new node."
  createNode(node: NewNode!): ValidationErrors!
  "Add node to node group."
  addNodeToGroup(nodeName: String!, groupName: String!): MaybeError!
  "Set state for node. Null clears the state."
  setNodeState(state: StateInput, nodeName: String!): ValidationErrors!
  "Update state of a node. The state has to be set."
  updateNodeState(state: StateUpdate!, nodeName: String!): ValidationErrors!
  "Create new diffusion between nodes."
  createNodeDiffusion(fromNode: String!, toNode: String!, coefficient: Float!): ValidationErrors!
  "Create new market."
  createMarket(market: NewMarket!): ValidationErrors!
  "Create new risk."
  createRisk(risk: NewRisk!): ValidationErrors!
  "Create new generic constraint."
  createGenConstraint(constraint: NewGenConstraint!): ValidationErrors!
  "Create new flow constraint factor and add it to generic constraint."
  createFlowConFactor(factor: Float!, constraintName: String!, processName: String!, sourceOrSinkNodeName: String!): ValidationErrors!
  "Create new state constraint factor and add it to generic constraint."
  createStateConFactor(factor: Float!, constraintName: String!, nodeName: String!): ValidationErrors!
  "Create new online constraint factor and add it to generic constraint."
  createOnlineConFactor(factor: Float!, constraintName: String!, processName: String!): ValidationErrors!
  updateSettings(settingsInput: SettingsInput!): SettingsResult!
}

type Node {
  name: String!
  groups: [String!]!
  isCommodity: Boolean!
  isMarket: Boolean!
  isRes: Boolean!
  state: State
  cost: Float
  inflow: Float
}

type NodeDiffusion {
  fromNode: String!
  toNode: String!
  coefficient: Float!
}

type NodeHistory {
  node: String!
  steps: Float!
}

type Point {
  x: Float!
  y: Float!
}

type Process {
  name: String!
  groups: [String!]!
  conversion: String!
  isCf: Boolean!
  isCfFix: Boolean!
  isOnline: Boolean!
  isRes: Boolean!
  eff: Float!
  loadMin: Float!
  loadMax: Float!
  startCost: Float!
  minOnline: Float!
  minOffline: Float!
  maxOnline: Float!
  maxOffline: Float!
  initialState: Boolean!
  isScenarioIndependent: Boolean!
  topos: [Topology!]!
  cf: Float!
  effTs: Float
  effOps: [String!]!
  effFun: [Point!]!
}

type Query {
  apiVersion: String!
  settings: Settings!
  model: Model!
  genConstraint(name: String!): GenConstraint!
  group(name: String!): Group!
  nodesInGroup(name: String!): [Node!]!
  processesInGroup(name: String!): [Process!]!
  market(name: String!): Market!
  node(name: String!): Node!
  "return all groups the given node is member of"
  groupsForNode(name: String!): [Group!]!
  nodeDiffusion(fromNode: String!, toNode: String!): NodeDiffusion!
  "return all groups the given process is member of"
  groupsForProcess(name: String!): [Group!]!
  process(name: String!): Process!
  scenario(name: String!): Scenario!
  status: Status!
}

type ReserveType {
  name: String!
  rampRate: Float!
}

type Risk {
  parameter: String!
  value: Float!
}

"Scenario for stochastics."
type Scenario {
  "Scenario name."
  name: String!
  "Scenario weight."
  weight: Float!
}

"General Hertta settings."
type Settings {
  "Device location."
  location: LocationSettings
}

type StartOptimizationError {
  message: String!
}

type StartOptimizationOutput {
  jobId: Int!
}

type State {
  inMax: Float!
  outMax: Float!
  stateLossProportional: Float!
  stateMax: Float!
  stateMin: Float!
  initialState: Float!
  isScenarioIndependent: Boolean!
  isTemp: Boolean!
  tEConversion: Float!
  residualValue: Float!
}

type Status {
  state: String!
  jobId: Int
  message: String
}

"Optimization time line settings."
type TimeLineSettings {
  "Time line duration."
  duration: Duration!
  "Time step length."
  step: Duration!
}

type Topology {
  source: String!
  sink: String!
  capacity: Float!
  vomCost: Float!
  rampUp: Float!
  rampDown: Float!
  initialLoad: Float!
  initialFlow: Float!
  capTs: Float
}

type ValidationError {
  field: String!
  message: String!
}

type ValidationErrors {
  errors: [ValidationError!]!
}

type VariableId {
  entity: String!
  identifier: String
}

union SettingsResult = Settings | ValidationErrors

union StartOptimizationResult = StartOptimizationOutput | StartOptimizationError