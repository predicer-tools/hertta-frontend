schema {
  query: Query
  mutation: Mutation       
}

enum ConstraintType {      
  LESS_THAN
  EQUAL
  GREATER_THAN
}

enum Conversion {
  UNIT
  TRANSPORT
  MARKET
}

enum ConversionFactorType {
  FLOW
  STATE
  ONLINE
}

enum JobState {
  QUEUED
  IN_PROGRESS
  FAILED
  FINISHED
}

enum MarketDirection {     
  UP
  DOWN
  UP_DOWN
}

enum MarketType {
  ENERGY
  RESERVE
}

input DurationInput {      
  hours: Int!
  minutes: Int!
  seconds: Int!
}

input InputDataSetupUpdate {
  containsReserves: Boolean
  containsOnline: Boolean
  containsStates: Boolean
  containsPiecewiseEff: Boolean
  containsRisk: Boolean
  containsDiffusion: Boolean
  containsDelay: Boolean
  containsMarkets: Boolean
  reserveRealization: Boolean
  useMarketBids: Boolean
  commonTimesteps: Int
  commonScenarioName: String
  useNodeDummyVariables: Boolean
  useRampDummyVariables: Boolean
  nodeDummyVariableCost: Float
  rampDummyVariableCost: Float
}

"Location input."
input LocationInput {
  "Country." country: String
  "Place within the country." place: String
}

input NewGenConstraint {
  name: String!
  gcType: ConstraintType!
  isSetpoint: Boolean!
  penalty: Float!
  constant: Float
}

input NewMarket {
  name: String!
  mType: MarketType!
  node: String!
  processGroup: String!
  direction: MarketDirection
  realisation: Float
  reserveType: String
  isBid: Boolean!
  isLimited: Boolean!
  minBid: Float!
  maxBid: Float!
  fee: Float!
  price: Float
  upPrice: Float
  downPrice: Float
  reserveActivationPrice: Float
}

input NewNode {
  name: String!
  isCommodity: Boolean!
  isMarket: Boolean!
  isRes: Boolean!
  cost: Float
  inflow: Float
}

input NewProcess {
  name: String!
  conversion: Conversion!
  isCfFix: Boolean!
  isOnline: Boolean!
  isRes: Boolean!
  eff: Float!
  loadMin: Float!
  loadMax: Float!
  startCost: Float!
  minOnline: Float!
  maxOnline: Float!
  minOffline: Float!
  maxOffline: Float!
  initialState: Boolean!
  isScenarioIndependent: Boolean!
  cf: Float
  effTs: Float
}

input NewRisk {
  parameter: String!
  value: Float!
}

input NewTopology {
  capacity: Float!
  vomCost: Float!
  rampUp: Float!
  rampDown: Float!
  initialLoad: Float!
  initialFlow: Float!
  capTs: Float
}

input SettingsInput {
  location: LocationInput
}

input StateInput {
  inMax: Float!
  outMax: Float!
  stateLossProportional: Float!
  stateMin: Float!
  stateMax: Float!
  initialState: Float!
  isScenarioIndependent: Boolean!
  isTemp: Boolean!
  tEConversion: Float!
  residualValue: Float!
}

input StateUpdate {
  inMax: Float
  outMax: Float
  stateLossProportional: Float
  stateMax: Float
  stateMin: Float
  initialState: Float
  isScenarioIndependent: Boolean
  isTemp: Boolean
  tEConversion: Float
  residualValue: Float
}

input TimeLineUpdate {
  duration: DurationInput
  step: DurationInput
}

"""
  Combined date and time (with time zone) in [RFC 3339][0] format.

  Represents a description of an exact instant on the time-line (such as the
  instant that a user account was created).

  [`DateTime` scalar][1] compliant.

  See also [`chrono::DateTime`][2] for details.

  [0]: https://datatracker.ietf.org/doc/html/rfc3339#section-5
  [1]: https://graphql-scalars.dev/docs/scalars/date-time
  [2]: https://docs.rs/chrono/latest/chrono/struct.DateTime.html
"""
scalar DateTime

type ConFactor {
  varType: ConversionFactorType!
  varTuple: VariableId!
  data: Float!
}

type ControlSignal {
  name: String!
  signal: [Float!]!
}

"Delay for connections between nodes."
type Delay {
  fromNode: Node!
  toNode: Node!
  delay: Float!
  minDelayFlow: Float!
  maxDelayFlow: Float!
}

type Duration {
  hours: Int!
  minutes: Int!
  seconds: Int!
}

type GenConstraint {
  name: String!
  gcType: ConstraintType!
  isSetpoint: Boolean!
  penalty: Float!
  factors: [ConFactor!]!
  constant: Float
}

type InflowBlock {
  name: String!
  node: Node!
  data: Float!
}

"The model itself."
type InputData {
  scenarios: [Scenario!]!
  setup: InputDataSetup!
  processes: [Process!]!
  nodes: [Node!]!
  nodeDiffusion: [NodeDiffusion!]!
  nodeDelay: [Delay!]!
  nodeHistories: [NodeHistory!]!
  markets: [Market!]!
  nodeGroups: [NodeGroup!]!
  processGroups: [ProcessGroup!]!
  reserveType: [ReserveType!]!
  risk: [Risk!]!
  inflowBlocks: [InflowBlock!]!
  genConstraints: [GenConstraint!]!
}

type InputDataSetup {
  containsReserves: Boolean!
  containOnline: Boolean!
  containsStates: Boolean!
  containsPiecewiseEff: Boolean!
  containsRisk: Boolean!
  containsDiffusion: Boolean!
  containsDelay: Boolean!
  containsMarkets: Boolean!
  reserveRealisation: Boolean!
  useMarketBids: Boolean!
  commonTimeSteps: Int!
  commonScenario: Scenario!
  useNodeDummyVariables: Boolean!
  useRampDummyVariables: Boolean!
  nodeDummyVariableCost: Float!
  rampDummyVariableCost: Float!
}

type JobStatus {
  state: JobState!
  message: String
}

type LocationSettings {
  "Country."
  country: String!
  "Place within country."
  place: String!
}

type Market {
  name: String!
  mType: MarketType!
  node: Node!
  processGroup: ProcessGroup!
  direction: MarketDirection
  realisation: Float
  reserveType: ReserveType
  isBid: Boolean!
  isLimited: Boolean!
  minBid: Float!
  maxBid: Float!
  fee: Float!
  price: Float
  upPrice: Float
  downPrice: Float
  reserveActivationPrice: Float
  fixed: [MarketFix!]!
}

type MarketFix {
  name: String!
  factor: Float!
}

type MaybeError {
  "Error message; if null, the operation succeeded."
  error: String
}

"Optimization model."
type Model {
  timeLine: TimeLineSettings!
  inputData: InputData!
}

type Mutation {
  "Start optimization job. Return job ID."
  startOptimization: Int!
  "Start weather forecast job. Return job ID."
  startWeatherForecastFetch: Int!
  "Update model's time line."
  updateTimeLine(timeLineInput: TimeLineUpdate!): ValidationErrors!
  "Create new scenario."
  createScenario(name: String!, weight: Float!): MaybeError!
  "Save the model on disk."
  saveModel: MaybeError!
  "Clear input data from model."
  clearInputData: MaybeError!
  "Update input data setup."
  updateInputDataSetup(setupUpdate: InputDataSetupUpdate!): ValidationErrors!
  "Create new node group"
  createNodeGroup(name: String!): MaybeError!
  "Create new process group."
  createProcessGroup(name: String!): MaybeError!
  "Create new process."
  createProcess(process: NewProcess!): ValidationErrors!
  "Add process to process group."
  addProcessToGroup(processName: String!, groupName: String!): MaybeError!
  "Create new topology and add it to process."
  createTopology(topology: NewTopology!, sourceNodeName: String, processName: String!, sinkNodeName: String): ValidationErrors!
  "Create new node."
  createNode(node: NewNode!): ValidationErrors!
  "Add node to node group."
  addNodeToGroup(nodeName: String!, groupName: String!): MaybeError!
  "Set state for node. Null clears the state."
  setNodeState(state: StateInput, nodeName: String!): ValidationErrors!
  "Update state of a node. The state has to be set."
  updateNodeState(state: StateUpdate!, nodeName: String!): ValidationErrors!
  "Create new diffusion between nodes."
  createNodeDiffusion(fromNode: String!, toNode: String!, coefficient: Float!): ValidationErrors!
  "Create new market."
  createMarket(market: NewMarket!): ValidationErrors!
  "Create new risk."
  createRisk(risk: NewRisk!): ValidationErrors!
  "Create new generic constraint."
  createGenConstraint(constraint: NewGenConstraint!): ValidationErrors!
  "Create new flow constraint factor and add it to generic constraint."
  createFlowConFactor(factor: Float!, constraintName: String!, processName: String!, sourceOrSinkNodeName: String!): ValidationErrors!
  "Create new state constraint factor and add it to generic constraint."
  createStateConFactor(factor: Float!, constraintName: String!, nodeName: String!): ValidationErrors!
  "Create new online constraint factor and add it to generic constraint."
  createOnlineConFactor(factor: Float!, constraintName: String!, processName: String!): ValidationErrors!
  updateSettings(settingsInput: SettingsInput!): SettingsResult!
}

type Node {
  name: String!
  groups: [NodeGroup!]!
  isCommodity: Boolean!
  isMarket: Boolean!
  isRes: Boolean!
  state: State
  cost: Float
  inflow: Float
}

type NodeDiffusion {
  fromNode: Node!
  toNode: Node!
  coefficient: Float!
}

type NodeGroup {
  name: String!
  members: [Node!]!
}

type NodeHistory {
  node: Node!
  steps: Float!
}

type OptimizationOutcome {
  time: [DateTime!]!
  controlSignals: [ControlSignal!]!
}

type Point {
  x: Float!
  y: Float!
}

type Process {
  name: String!
  groups: [ProcessGroup!]!
  conversion: Conversion!
  isCf: Boolean!
  isCfFix: Boolean!
  isOnline: Boolean!
  isRes: Boolean!
  eff: Float!
  loadMin: Float!
  loadMax: Float!
  startCost: Float!
  minOnline: Float!
  minOffline: Float!
  maxOnline: Float!
  maxOffline: Float!
  isScenarioIndependent: Boolean!
  topos: [Topology!]!
  cf: Float!
  effTs: Float
  effOps: [String!]!
  effFun: [Point!]!
}

type ProcessGroup {
  name: String!
  members: [Process!]!
}

type Query {
  apiVersion: String!
  settings: Settings!
  model: Model!
  genConstraint(name: String!): GenConstraint!
  nodeGroup(name: String!): NodeGroup!
  nodesInGroup(name: String!): [Node!]!
  processGroup(name: String!): ProcessGroup!
  processesInGroup(name: String!): [Process!]!
  market(name: String!): Market!
  node(name: String!): Node!
  "Return all groups the given node is member of."
  groupsForNode(name: String!): [NodeGroup!]!
  nodeDiffusion(fromNode: String!, toNode: String!): NodeDiffusion!
  "Return all groups the given process is member of."
  groupsForProcess(name: String!): [ProcessGroup!]!
  process(name: String!): Process!
  scenario(name: String!): Scenario!
  jobStatus(jobId: Int!): JobStatus!
  jobOutcome(jobId: Int!): JobOutcome!
}

type ReserveType {
  name: String!
  rampRate: Float!
}

type Risk {
  parameter: String!
  value: Float!
}

"Scenario for stochastics."
type Scenario {
  "Scenario name."
  name: String!
  "Scenario weight."
  weight: Float!
}

"General Hertta settings."
type Settings {
  "Device location."
  location: LocationSettings
}

type State {
  inMax: Float!
  outMax: Float!
  stateLossProportional: Float!
  stateMax: Float!
  stateMin: Float!
  initialState: Float!
  isScenarioIndependent: Boolean!
  isTemp: Boolean!
  tEConversion: Float!
  residualValue: Float!
}

"Optimization time line settings."
type TimeLineSettings {
  "Time line duration."
  duration: Duration!
  "Time step length."
  step: Duration!
}

type Topology {
  source: NodeOrProcess!
  sink: NodeOrProcess!
}

type ValidationError {
  field: String!
  message: String!
}

type ValidationErrors {
  errors: [ValidationError!]!
}

type VariableId {
  entity: NodeOrProcess!
  identifier: Node
}

type WeatherForecastOutcome {
  time: [DateTime!]!
  temperature: [Float!]!
}

union JobOutcome = OptimizationOutcome | WeatherForecastOutcome

union NodeOrProcess = Node | Process

union SettingsResult = Settings | ValidationErrors